using System;
using System.Collections.Generic;
using System.Linq;
using NGRM.Domain.Entities;
using NGRM.Domain.Interfaces.Mappers;
using NGRM.Domain.Interfaces.Repositories;
using NGRM.Domain.Interfaces.Services;
using NGRM.Domain.Lookups;
using NGRM.Domain.Model;
using NGRM.Domain.Utils;

namespace NGRM.Domain.Services
{
    public class VulnerabilityService : IVulnerabilityService
    {
        private readonly IVulnerabilityMapper _vulnerabilityMapper;
        private readonly IHostMapper _hostMapper;
        private readonly IRiskMapper _riskMapper;
        private readonly IVulnerabilityRepository _vulnerabilityRepository;
        private readonly IImportRepository _importRepository;
        
        private readonly IHostService _hostService;

        public VulnerabilityService(IVulnerabilityRepository vulnerabilityRepository,
            IImportRepository importRepository,
            IVulnerabilityMapper vulnerabilityMapper,
            IHostMapper hostMapper,
            IRiskMapper riskMapper,
            IHostService hostService)
        {
            _vulnerabilityMapper = vulnerabilityMapper;
            _hostMapper = hostMapper;
            _riskMapper = riskMapper;
            _vulnerabilityRepository = vulnerabilityRepository;
            _importRepository = importRepository;
            _hostService = hostService;
        }

        public IEnumerable<MiniVulnerability> GetVulnerabilities(int engagementId)
        {
            var latestImport = _importRepository.GetLatest(engagementId);
            var penultimateImport = _importRepository.GetPenultimate(engagementId);
            var vulnerabilities = _vulnerabilityRepository.GetByEngagementId(engagementId).ToList();
            var latestVulnerabilityEntities = vulnerabilities
                .Where(x => x.PhaseId == latestImport.PhaseId);
            var otherVulnerabilityEntities = vulnerabilities
                .Except(latestVulnerabilityEntities);
            var allVulnerabilityEntities = new List<MiniVulnerability>();

            // Create a list of vulns within the current phase that are either historical, have an unknown status
            // ('offline' or 'retired'), or have an existing host in the latest import.
            foreach (var latestVulnerabilityEntity in latestVulnerabilityEntities)
            {
                var vulnerability = _vulnerabilityMapper.MapToMinimalModel(latestVulnerabilityEntity);
                vulnerability.HostListCount = CountHosts(latestVulnerabilityEntity, latestImport.Id);
                allVulnerabilityEntities.Add(vulnerability);
            }

            // Now go through ALL THE PREVIOUS importssac belonging to that phase and add more vulns to the vuln list as appropriate.
            // Keep in mind, something can be "historical" from many imports ago and they still need to be included here.
            foreach (var otherVulnerabilityEntity in otherVulnerabilityEntities)
            { 
                var vulnerability = _vulnerabilityMapper.MapToMinimalModel(otherVulnerabilityEntity);
                var latestImportInPhase = _importRepository.GetLatestByPhaseId(otherVulnerabilityEntity.PhaseId);
                var penultimateImportInPhase = _importRepository.GetPenultimateByPhaseId(otherVulnerabilityEntity.PhaseId);
                vulnerability.HostListCount = CountHosts(otherVulnerabilityEntity, latestImportInPhase.Id);

                if (vulnerability.HostListCount > 0 || vulnerability.IsStatusUnknown || vulnerability.IsHistorical)
                    allVulnerabilityEntities.Add(vulnerability);
            }

            return allVulnerabilityEntities;
        }

        public Vulnerability Get(int vulnerabilityId)
        {
            Guard.ForLessOrEqualZero(vulnerabilityId, "vulnerabilityId");

            var vulnerabilityEntity = _vulnerabilityRepository.Get(vulnerabilityId);
            if (vulnerabilityEntity == null)
                return null;

            var latestImportInPhase = _importRepository.GetLatestByPhaseId(vulnerabilityEntity.PhaseId);

            var vulnerability = _vulnerabilityMapper.Map(vulnerabilityEntity);
            MapHostList(vulnerabilityEntity, vulnerability, latestImportInPhase.Id);

            var riskEntities = vulnerabilityEntity.RiskVulnerabilities.Select(x => x.Risk);
            vulnerability.RiskList = riskEntities.Select(_riskMapper.Map).ToList();

            return vulnerability;
        }

        public Vulnerability GetWithCompleteHostList(int vulnerabilityId, int phaseId)
        {
            Guard.ForLessOrEqualZero(vulnerabilityId, "vulnerabilityId");
            Guard.ForLessOrEqualZero(phaseId, "phaseId");
            var isVulnDetailsHostList = true;

            var vulnerabilityEntity = _vulnerabilityRepository.Get(vulnerabilityId);
            if (vulnerabilityEntity == null)
                return null;

            var vulnerability = _vulnerabilityMapper.Map(vulnerabilityEntity);
            var hosts = _hostService.GetHosts(vulnerabilityEntity.EngagementId, phaseId, vulnerabilityId, isVulnDetailsHostList).ToList();

            vulnerability.HostList = hosts;

            var riskEntities = vulnerabilityEntity.RiskVulnerabilities.Select(x => x.Risk);
            vulnerability.RiskList = riskEntities.Select(_riskMapper.Map).ToList();

            return vulnerability;
        }

        public void Add(Vulnerability vulnerability)
        {
            Guard.ForArgumentIsNull(vulnerability, "vulnerability");

            var vulnerabilityEntity = _vulnerabilityMapper.Map(vulnerability);
            _vulnerabilityRepository.Add(vulnerabilityEntity);

            _vulnerabilityRepository.Save();
        }

        public void Update(Vulnerability vulnerability)
        {
            Guard.ForArgumentIsNull(vulnerability, "vulnerability");

            var vulnerabilityId = Convert.ToInt32(vulnerability.Id);
            Guard.ForLessOrEqualZero(vulnerabilityId, "vulnerability.Id");

            var vulnerabilityEntity = _vulnerabilityRepository.Get(vulnerabilityId);
            _vulnerabilityMapper.Map(vulnerability, vulnerabilityEntity);

            _vulnerabilityRepository.Save();
        }

        public IEnumerable<MiniVulnerability> GetExportData(int engagementId)
        {
            var latestImport = _importRepository.GetLatest(engagementId);
            var penultimateImport = _importRepository.GetPenultimate(engagementId);
            var vulnerabilities = _vulnerabilityRepository.GetExportData(engagementId).ToList();
            var latestVulnerabilityEntities = vulnerabilities
                .Where(x => x.PhaseId == latestImport.PhaseId);
            var otherVulnerabilityEntities = vulnerabilities
                .Except(latestVulnerabilityEntities);
            var allVulnerabilityEntities = new List<MiniVulnerability>();

            // Create a list of vulns within the current phase that are either historical, have an unknown status
            // ('offline' or 'retired'), or have an existing host in the latest import.
            foreach (var latestVulnerabilityEntity in latestVulnerabilityEntities)
            {
                var vulnerability = _vulnerabilityMapper.MapToMinimalModel(latestVulnerabilityEntity);
                vulnerability.HostListCount = CountHosts(latestVulnerabilityEntity, latestImport.Id);
                allVulnerabilityEntities.Add(vulnerability);
            }

            // Now go through ALL THE PREVIOUS imports belonging to that phase and add more vulns to the vuln list as appropriate.
            // Keep in mind, something can be "historical" from many imports ago and they still need to be included here.
            foreach (var otherVulnerabilityEntity in otherVulnerabilityEntities)
            { 
                var vulnerability = _vulnerabilityMapper.MapToMinimalModel(otherVulnerabilityEntity);
                var latestImportInPhase = _importRepository.GetLatestByPhaseId(otherVulnerabilityEntity.PhaseId);
                var penultimateImportInPhase = _importRepository.GetPenultimateByPhaseId(otherVulnerabilityEntity.PhaseId);
                vulnerability.HostListCount = CountHosts(otherVulnerabilityEntity, latestImportInPhase.Id);

                if (vulnerability.HostListCount > 0 || vulnerability.IsStatusUnknown || vulnerability.IsHistorical)
                    allVulnerabilityEntities.Add(vulnerability);
            }

            return allVulnerabilityEntities;
        } 

        public void RemediateByRetiredHost(Host host)
        {
            var hostEntity = _hostMapper.Map(host);   
            var vulnerabilityEntities = _vulnerabilityRepository.GetByEngagementId(hostEntity.EngagementId)
                .Where(x => x.PhaseId == hostEntity.PhaseId).ToList();

            foreach (var vulnerabilityEntity in vulnerabilityEntities)
            {
                var vulnerability = _vulnerabilityMapper.Map(vulnerabilityEntity);
            
                MapHostList(vulnerabilityEntity, vulnerability);

                // Determine if this is the last host for this vuln.
                // If NONE of the remaining hosts in the HostList is 'Active' or 'Offline',
                // then remediate the vulnerability.
                if (!vulnerability.HostList.Any(x => (x.Status == "Active" || x.Status == "Offline")))
                {
                    vulnerability.IsStatusUnknown = false;
                    vulnerability.IsHistorical = true;
                    vulnerability.PreviousRemediationStatusId = vulnerability.RemediationStatusId;
                    vulnerability.RemediationStatusId = Lookups.MitigationStatus.FullyMitigated.Value.ToString();
                    vulnerability.MitigationDate = vulnerability.ImportedDate;            
                }
                _vulnerabilityMapper.Map(vulnerability, vulnerabilityEntity);
            }
            _vulnerabilityRepository.Save();
        }

        public void ReactivateByHost(Host host)
        {
            var hostEntity = _hostMapper.Map(host);   
            var vulnerabilityEntities = _vulnerabilityRepository.GetByEngagementId(hostEntity.EngagementId)
                .Where(x => x.PhaseId == hostEntity.PhaseId && x.PreviousRemediationStatusId != null)
                .ToList();
            
            foreach (var vulnerabilityEntity in vulnerabilityEntities)
            {
                var vulnerability = _vulnerabilityMapper.Map(vulnerabilityEntity);

                vulnerability.IsStatusUnknown = true;
                vulnerability.IsHistorical = false;
                vulnerability.RemediationStatusId = vulnerability.PreviousRemediationStatusId;
                vulnerability.PreviousRemediationStatusId = null;
                vulnerability.MitigationDate = null;            
                _vulnerabilityMapper.Map(vulnerability, vulnerabilityEntity);
            }
            _vulnerabilityRepository.Save();
        }

        private void MapHostList(VulnerabilityEntity source, Vulnerability destination, int? latestImportId = null)
        {
            foreach (var hostVulnerability in source.HostVulnerabilities)
            {
                if ( (latestImportId != null && hostVulnerability.ImportId == latestImportId) || latestImportId == null )
                {   
                    var host = _hostMapper.Map(hostVulnerability.Host);
                    destination.HostList.Add(host);
                }

            }
        }

        private int CountHosts(VulnerabilityEntity source, int? latestImportId = null)
        {
            
            if (latestImportId == null)
                return source.HostVulnerabilities.Count();

            var hostCount = 0;

            foreach (var hostVulnerability in source.HostVulnerabilities)
            {
                if (hostVulnerability.ImportId == latestImportId || hostVulnerability.Host.Status == "Offline")
                {
                    hostCount++;
                }
            }

            return hostCount;
        }
    }
}
