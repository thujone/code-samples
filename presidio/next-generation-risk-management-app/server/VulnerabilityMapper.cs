using System;
using System.Linq;
using NGRM.Domain.Entities;
using NGRM.Domain.Interfaces.Mappers;
using NGRM.Domain.Interfaces.Services;
using NGRM.Domain.Lookups;
using NGRM.Domain.Model;

namespace NGRM.Domain.Mappers
{
    public class VulnerabilityMapper : Mapper<Vulnerability, VulnerabilityEntity>, IVulnerabilityMapper
    {
        public VulnerabilityMapper(ICryptographyService cryptographyService) : base(cryptographyService)
        {
        }

        protected override void MapToModel(VulnerabilityEntity source, Vulnerability destination)
        {
            destination.Id = source.Id.ToString();
            destination.EngagementId = source.EngagementId.ToString();
            destination.PhaseId = source.PhaseId.ToString();
            destination.Phase = source.Phase?.Name ?? "Unknown";
            destination.VulnerabilityCategory = source.VulnerabilityCategory;
            destination.ResourceId = source.ResourceId;
            destination.GroupId = source.GroupId;
            destination.Title = Decrypt<string>(source.TitleBytes);
            destination.CVSSScore = source.CvssScore;
            destination.Description = Decrypt<string>(source.DescriptionBytes);
            destination.Remedy = Decrypt<string>(source.RemedyBytes);
            destination.References = Decrypt<string>(source.ReferencesBytes)?.Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries).ToList();
            destination.Port = Decrypt<int?>(source.PortBytes).ToString();
            destination.Service = Decrypt<string>(source.ServiceBytes);
            destination.ScanDetails = Decrypt<string>(source.ScanDetailsBytes);
            destination.PatchDate = source.PatchDate?.ToString("M/d/yyyy") ?? string.Empty;
            destination.ImportedBy = source.ImportedBy;
            destination.ImportedDate = source.ImportedDate?.ToString("M/d/yyyy") ?? string.Empty;
            destination.ExploitAvailable = Decrypt<bool?>(source.ExploitAvailableBytes).GetValueOrDefault();
            destination.VulnerabilityDate = source.ReportedDate?.ToString("M/d/yyyy") ?? string.Empty;
            destination.CVEList = Decrypt<string>(source.CveBytes)?.TrimStart('[').TrimEnd(']').Replace("\'", "").Split(new[] {','}, StringSplitOptions.RemoveEmptyEntries).ToList();
            destination.ExploitList = Decrypt<string>(source.ExploitableWithBytes)?.TrimStart('[').TrimEnd(']').Replace("\'", "").Split(new[] {','}, StringSplitOptions.RemoveEmptyEntries).ToList();
            destination.Severity = ThreatLevel.LookupByValue(source.CvssScore)?.Name ?? string.Empty;
            destination.RemediationResource = GetRemediationResource(source);
            destination.RemediationStatus = MitigationStatus.LookupByValue(source.RemediationStatusId.GetValueOrDefault())?.Name;
            destination.RemediationStatusId = source.RemediationStatusId.ToString();
            destination.PreviousRemediationStatusId = source.PreviousRemediationStatusId.ToString();
            destination.MitigationDate = source.MitigatedDate?.ToString("M/d/yyyy");
            destination.AssessmentDate = source.AssessmentDate?.ToString("M/d/yyyy");
            destination.TargetRemediationDate = source.TargetRemediationDate?.ToString("M/d/yyyy");
            destination.IsHistorical = source.IsHistorical;
            destination.IsStatusUnknown = source.IsStatusUnknown;
            var riskVulnerabilityEntity = source.RiskVulnerabilities.FirstOrDefault();
            destination.Risk = riskVulnerabilityEntity != null ? Decrypt<string>(riskVulnerabilityEntity.Risk.NameBytes) : "Unknown";
        }

        public MiniVulnerability MapToMinimalModel(VulnerabilityEntity source)
        {
            var destination = new MiniVulnerability();
            destination.Id = source.Id.ToString();
            destination.PhaseId = source.PhaseId.ToString();
            destination.Phase = source.Phase?.Name ?? "Unknown";
            destination.VulnerabilityCategory = source.VulnerabilityCategory;
            destination.Title = Decrypt<string>(source.TitleBytes);
            destination.Severity = ThreatLevel.LookupByValue(source.CvssScore)?.Name ?? string.Empty;
            destination.RemediationResource = GetRemediationResource(source);
            destination.IsHistorical = source.IsHistorical;
            destination.IsStatusUnknown = source.IsStatusUnknown;
            var riskVulnerabilityEntity = source.RiskVulnerabilities.FirstOrDefault();
            destination.Risk = riskVulnerabilityEntity != null ? Decrypt<string>(riskVulnerabilityEntity.Risk.NameBytes) : "Unknown";
            return destination;
        }

        protected override void MapToEntity(Vulnerability source, VulnerabilityEntity destination)
        {
            destination.EngagementId = Convert.ToInt32(source.EngagementId);
            destination.PhaseId = Convert.ToInt32(source.PhaseId);
            destination.ResourceId = source.ResourceId;
            destination.GroupId = source.GroupId;
            destination.RemediationStatusId = string.IsNullOrWhiteSpace(source.RemediationStatusId) ? (int?)null : Convert.ToInt32(source.RemediationStatusId);
            destination.PreviousRemediationStatusId = string.IsNullOrWhiteSpace(source.PreviousRemediationStatusId) ? (int?)null : Convert.ToInt32(source.PreviousRemediationStatusId);
            destination.MitigatedDate = string.IsNullOrWhiteSpace(source.MitigationDate) ? (DateTime?)null : Convert.ToDateTime(source.MitigationDate);
            destination.AssessmentDate = string.IsNullOrWhiteSpace(source.AssessmentDate) ? (DateTime?)null : Convert.ToDateTime(source.AssessmentDate);
            destination.TargetRemediationDate = string.IsNullOrWhiteSpace(source.TargetRemediationDate) ? (DateTime?)null : Convert.ToDateTime(source.TargetRemediationDate);
            destination.IsHistorical = source.IsHistorical;
            destination.IsStatusUnknown = source.IsStatusUnknown;
        }

        private string GetRemediationResource(VulnerabilityEntity source)
        {
            if (source.Resource != null)
                return source.Resource.Name;
            if (source.Group != null)
                return source.Group.Name;
            return string.Empty;
        }
    }
}